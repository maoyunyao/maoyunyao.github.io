<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Inline Assembler in GCC]]></title>
    <url>%2F2018%2F09%2F09%2Finline-asm-gcc%2F</url>
    <content type="text"><![CDATA[操作系统上机知识储备(一)对gcc所支持的内联汇编格式及使用方法进行简要的介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* * This c file is a introduction of inline Assembly for gcc * Time： 2018/9/8 * Author: myy * Reference： JeffreyLi https://www.jianshu.com/p/1782e14a0766*//////////////////////////////////////////////////////////////////////////////////////////////*Formular: asm ( assembler template : output operands // optional : input operands // optional : list of clobbered registers // optional ); The assembler template form: * form1:"sentence?sentence?sentence" * form2: "sentence?" "sentence?" "sentence" --- Where the ? should be replaced by "\n\t" or ";". --- Access to C variables by %0 %1 and so on. The operands form: * "constraint" (C expression) --- Where constraint is mainly used for note Addressing type(memory or register). --- For output operants, it should be decorated by "=", which means write-only. --- For multiple operants, they should be seperated by ",". --- To use the operants in assempler template with %0 %1 %2 ... - First output operants then input operants. - Signed in the list order. --- The output operants must be lvalue. The clobber list: * When a register is used in the assembler template, it should be in the clobber list. Which let gcc no longer assume that the values previously stored in these registers are still legal. * If the instruction changes the memory value in an unpredictable form, you need to add "memory" to the clobbered list.This allows GCC not to cache these memory values. The volatile: * If the assembly code is required to be executed at the location where it was placed (for example, it cannot be moved out of the loop during the optimization), we need to put a "volatile" keyword before the "()" after asm. This will prevent these codes from being moved or deleted. --- Useage: __asm__volatile__(...); Common constraints: *********************** * r Register(s) * a %eax, %ax, %al * b %ebx, %bx, %bl * c %ecx, %cx, %cl * d %edx, %dx, %adl * S %esi, %si * D %edi, %di *********************** * m memory *********************** --- If use the register constraint, the value will first be stored at the register used, and then write back to the memory in the end. --- Constraint "0" means: use the same register as the first output operants. Constraint Modifiers: * "=": Write only. * "&amp;": Means that this operand is an earlyclobber operand, which is modified before the instruction is finished using the input operands. Therefore, this operand may not lie in a register that is used as an input operand or as part of any memory address. An input operand can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written.*/////////////////////////////////////////////////////////////////////////////////////////////#include&lt;stdio.h&gt;int main()&#123; int a = 10,b = 5,c; //Example: to realize c = a + b __asm__ __volatile__ ( "movl %2,%%eax\n\t movl %1,%%ebx\n\t addl %%ebx,%%eax\n\t movl %%eax,%0" :"=r"(c) :"r"(a),"r"(b) :"eax","ebx" ); printf("c = a + b = %d\n",c); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[FFT with python]]></title>
    <url>%2F2018%2F06%2F14%2Ffft-by-python%2F</url>
    <content type="text"><![CDATA[来自信号与系统的一个小作业用python和其开源的科学计算库numpy实现快速傅里叶变换算法，并用数据可视化开源第三方库matplotlib作出频域图样。 代码实现如下12345678910111213141516171819202122232425262728293031323334#导入第三方库###############################from numpy import *from math import *import matplotlib.pyplot as plt################################ TO GET THE DATA（take gauss signal sampling for example）data_list = [ exp(-pi*x*x/1024/1024) for x in range(0,1024)]# FFT FUNCTION PART (递归蝶形算法，输入为数据点数目和数据点列)def my_fft_fun(NUM, DATA): if NUM == 1: return DATA else: ODD_DATA=DATA[0::2] EVEN_DATA=DATA[1::2] ODD_LIST=my_fft_fun(NUM//2, ODD_DATA) #奇偶分治 EVEN_LIST=my_fft_fun(NUM//2, EVEN_DATA) #奇偶分治 RES_DATA=[ EVEN_LIST[k%(NUM//2)]+ODD_LIST[k%(NUM//2)]*(cos(2*pi*k/NUM)+sin(2*pi*k/NUM)*1j) for k in range(0,NUM)] return RES_DATA#调用定义好的FFT递归求解函数FINAL_RES=my_fft_fun(1024,data_list)# 作出X(k)的模值与k的关系图x_part=range(0,1024)y_part=[ abs(val) for val in FINAL_RES]plt.scatter(x_part,y_part,s=5)plt.title('DFT for Gauss Signal', fontsize=20)plt.xlabel('k', fontsize=14)plt.ylabel('X(k)', fontsize=14)plt.show() 效果作图如下 有待改进之处算法仅涉及简单情形，即数据点的个数是2的指数倍，当需要计算非2的指数倍个数据点的FFT时，分治算法需要更加复杂。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Zero contact]]></title>
    <url>%2F2018%2F06%2F13%2Fzero-contact%2F</url>
    <content type="text"><![CDATA[不如来一段紧张刺激的Hello,World代码如何： 1&gt;&gt;&gt; print("Hello,World!") THE END…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
