<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习之损失函数]]></title>
    <url>%2F2019%2F05%2F13%2Floss-function%2F</url>
    <content type="text"><![CDATA[似然函数在数理统计学中, 似然函数是一种关于统计模型中的参数的函数, 表示模型参数的似然性. 统计学中似然性和概率有着明确的区分. 概率用于在已知一些参数的情况下, 预测接下来在观测上所得到的结果. 而似然性则是用于在已知某些观测所得到的结果时, 对相关参数进行估值. 似然函数的重要性不是它的具体取值, 而是当参数变化时函数到底是变大还是变小. 对同一个似然函数, 其所代表的模型中, 某项参数值具有多种可能, 但如果存在一个参数值使得它的函数值达到最大的话, 那么这个值就是该项参数最为”合理”的参数值. 在已知某个参数 $B$ 时, 事件 $A$ 会发生的概率写作: P(A|B) = \frac{P(A,B)}{P(B)}由贝叶斯公式, 可知: P(B|A) = \frac{P(A|B)P(B)}{P(A)}故而, 我们可以反过来构造表示似然性的方法, 即已知有事件 $A$ 发生, 运用似然函数 $L(B|A)$ 估计参数 $B$ 的可能性.前面我们已经提到, 似然函数的重要性在于相对大小而不要求满足归一化条件. 因此我们将一个似然函数乘以一个正的常数后仍然是似然函数. 而对于特定的问题, $\frac{P(B)}{P(A)}$ 为不变的常数, 则: L(b|A) = \alpha P(A|B=b)当令 $\alpha=1$ 时, 关于参数 $B$ 的似然函数与给定参数 $B$ 的值后观测 $A$ 的条件概率等价. 似然函数作为损失函数既然似然函数可以用于在已知观测结果时对模型参数进行估值, 那么自然地可以作为机器学习中的损失函数来指导训练过程. 考虑判别式模型中的场景, 作为损失函数的似然函数接收 $\textbf{label}$ 与 $\textbf{predict}$ 两部分输入. 其中 $\textbf{label}$ 为训练集的标签也就是一次观测时各类别的确切概率值, 如 $[0,…0,1,0…0]$. 而 $\textbf{predict}$ 为模型在给定输入后输出的各类别预测概率分布. 似然函数的目的就是衡量 $\textbf{predict}$ 背后的模型对于观测值,即 $\textbf{label}​$ 的解释程度. 那么此时结合之前似然函数的讨论, 我们需要最大化似然函数, 即使得基于预测 $\textbf{predict}$ 时产生观测 $\textbf{label}$ 的概率最大. 单个样本时, 我们计算给定 $\textbf{predict}$ 时产生观测 $\textbf{label}$ 的概率如下: P = \prod_{i=1}^{C}predict(i)^{label(i)}\\ 注:其中C为类别数目下面我们对整个样本集(符合独立同分布定理)进行计算分析, 可将似然函数等价为条件概率: L = \prod_{j=1}^{m}\prod_{i=1}^{C}predict(i)^{label(i)}\\ 注:其中m为训练集大小由于指数以及累乘的存在, 很自然的我们想到对似然函数进行对数运算. 于是得到了所谓的对数似然函数. 由于对数的单调特性, 最大化似然函数等价于最大化对数似然函数. L = \sum\limits_{j=1}^{m}\sum\limits_{i=1}^{C}label(i)*log(predict(i))\\对数似然函数与交叉熵对数似然函数的形式与交叉熵极其相似, 事实上两者只相差了常系数项. 将上式中的对数似然函数除以m并取负数便得到所谓的负对数似然函数, 与交叉熵的形式一模一样. 于是原优化问题转化为最小化负对数似然函数, 即交叉熵.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习之核函数]]></title>
    <url>%2F2019%2F05%2F12%2Fkernel_method%2F</url>
    <content type="text"><![CDATA[核函数对于线性不可分样本问题(如简单的异或问题), 可以将样本从原始空间映射到一个更高维的特征空间, 使得样本在这个特征空间内线性可分. 例如在支持向量机中, 原问题转化为求解特征空间上的凸二次规划问题: f(\textbf{x}) = w^T \phi(\textbf{x}) + b对上述线性可分支持向量机的求解涉及到如下对偶问题的求解(由拉格朗日乘子法得到对偶问题的具体过程此处不予讨论): \mathop{max}_\alpha \quad \sum\limits_{i = 1}^{n}\alpha_i-\frac{1}{2}\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}\alpha_i\alpha_jy_iy_j\phi(\textbf{x}_i)^T\phi(\textbf{x}_j)\\ s.t. \quad \sum\limits_{i=1}^{m}\alpha_iy_i=0\\ \alpha_i \ge 0, \quad i=1,2,...,m求解上式涉及到计算 $\phi(\textbf{x}_i)^T\phi(\textbf{x}_j)$, 这是样本 $\textbf{x}_i$ 与$\textbf{} $$\textbf{x}_j$ 映射到特征空间之后的内积. 由于特征空间维数很高, 甚至可能是无穷维, 因此直接计算通常是困难的. 为了避开这个障碍, 可以设想这样一个函数: k(\textbf{x}_i,\textbf{x}_j)==\phi(\textbf{x}_i)^T\phi(\textbf{x}_j)即 $\textbf{x}_i$ 与 $\textbf{x}_j$ 在特征空间的内积等于它们在原始样本空间中通过函数 $k(.,.)$ 计算的结果(此即核技巧). 有了这样的函数我们就不必直接去计算高维甚至无穷维特征空间中的内积, 于是对偶问题重写并求解可得 f(\textbf{x})=w^T\phi(\textbf{x})+b\\ =\sum\limits_{i=1}^{m}\alpha_iy_i\phi(\textbf{x}_i)^T\phi(\textbf{x})+b\\ =\sum\limits_{i=1}^{m}\alpha_iy_ik(\textbf{x},\textbf{x}_i)+b\\这里的函数 $k(.,.)$ 就是 “核函数” 显然, 如果已知合适的映射 $\phi(.)$ 的具体形式, 则可写出核函数 $k(.,.)$. 但是 现实任务重我们通常不知道 $\phi(.)$ 是什么形式. 剩下的问题就是如何选择 $\phi(.)$: 使用一个通用的 $\phi$, 例如无限维的 $\phi$, 它隐含地用在高斯核也即基于径向基函数 $(RBF)$ 核的核机器上 手动地设计 $\phi$ , 在深度学习出现以前, 这一直是主流的方法 深度学习的策略是去学习 $\phi$ 参考文献: [1]机器学习-周志华-第126, 127页 [2]深度学习-花书-第106页]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inline Assembler in GCC]]></title>
    <url>%2F2018%2F10%2F05%2Finline-asm-gcc%2F</url>
    <content type="text"><![CDATA[操作系统上机知识储备(一)对gcc所支持的内联汇编格式及使用方法进行简要的介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* * This c file is a introduction of inline Assembly for gcc * Time： 2018/9/8 * Author: myy * Reference： JeffreyLi https://www.jianshu.com/p/1782e14a0766*//////////////////////////////////////////////////////////////////////////////////////////////*Formular: asm ( assembler template : output operands // optional : input operands // optional : list of clobbered registers // optional ); The assembler template form: * form1:"sentence?sentence?sentence" * form2: "sentence?" "sentence?" "sentence" --- Where the ? should be replaced by "\n\t" or ";". --- Access to C variables by %0 %1 and so on. The operands form: * "constraint" (C expression) --- Where constraint is mainly used for note Addressing type(memory or register). --- For output operants, it should be decorated by "=", which means write-only. --- For multiple operants, they should be seperated by ",". --- To use the operants in assempler template with %0 %1 %2 ... - First output operants then input operants. - Signed in the list order. --- The output operants must be lvalue. The clobber list: * When a register is used in the assembler template, it should be in the clobber list. Which let gcc no longer assume that the values previously stored in these registers are still legal. * If the instruction changes the memory value in an unpredictable form, you need to add "memory" to the clobbered list.This allows GCC not to cache these memory values. The volatile: * If the assembly code is required to be executed at the location where it was placed (for example, it cannot be moved out of the loop during the optimization), we need to put a "volatile" keyword before the "()" after asm. This will prevent these codes from being moved or deleted. --- Useage: __asm__ __volatile__(...); Common constraints: *********************** * r Register(s) * a %eax, %ax, %al * b %ebx, %bx, %bl * c %ecx, %cx, %cl * d %edx, %dx, %adl * S %esi, %si * D %edi, %di *********************** * m memory *********************** --- If use the register constraint, the value will first be stored at the register used, and then write back to the memory in the end. --- Constraint "0" means: use the same register as the first output operants. Constraint Modifiers: * "=": Write only. * "&amp;": Means that this operand is an earlyclobber operand, which is modified before the instruction is finished using the input operands. Therefore, this operand may not lie in a register that is used as an input operand or as a part of any memory address.An input operand can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written.*/////////////////////////////////////////////////////////////////////////////////////////////#include&lt;stdio.h&gt;int main()&#123; int a = 10,b = 5,c; //Example: to realize c = a + b __asm__ __volatile__ ( "movl %2,%%eax\n\t movl %1,%%ebx\n\t addl %%ebx,%%eax\n\t movl %%eax,%0" :"=r"(c) :"r"(a),"r"(b) :"eax","ebx" ); printf("c = a + b = %d\n",c); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[FFT with python]]></title>
    <url>%2F2018%2F04%2F01%2Ffft-by-python%2F</url>
    <content type="text"><![CDATA[来自信号与系统的一个小作业用python和其开源的科学计算库numpy实现快速傅里叶变换算法，并用数据可视化开源第三方库matplotlib作出频域图样。 代码实现如下12345678910111213141516171819202122232425262728293031323334#导入第三方库###############################from numpy import *from math import *import matplotlib.pyplot as plt################################ TO GET THE DATA（take gauss signal sampling for example）data_list = [ exp(-pi*x*x/1024/1024) for x in range(0,1024)]# FFT FUNCTION PART (递归蝶形算法，输入为数据点数目和数据点列)def my_fft_fun(NUM, DATA): if NUM == 1: return DATA else: ODD_DATA=DATA[0::2] EVEN_DATA=DATA[1::2] ODD_LIST=my_fft_fun(NUM//2, ODD_DATA) #奇偶分治 EVEN_LIST=my_fft_fun(NUM//2, EVEN_DATA) #奇偶分治 RES_DATA=[ EVEN_LIST[k%(NUM//2)]+ODD_LIST[k%(NUM//2)]*(cos(2*pi*k/NUM)+sin(2*pi*k/NUM)*1j) for k in range(0,NUM)] return RES_DATA#调用定义好的FFT递归求解函数FINAL_RES=my_fft_fun(1024,data_list)# 作出X(k)的模值与k的关系图x_part=range(0,1024)y_part=[ abs(val) for val in FINAL_RES]plt.scatter(x_part,y_part,s=5)plt.title('DFT for Gauss Signal', fontsize=20)plt.xlabel('k', fontsize=14)plt.ylabel('X(k)', fontsize=14)plt.show() 效果作图如下 有待改进之处算法仅涉及简单情形，即数据点的个数是2的指数倍，当需要计算非2的指数倍个数据点的FFT时，分治算法需要更加复杂。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Zero contact]]></title>
    <url>%2F2018%2F02%2F08%2Fzero-contact%2F</url>
    <content type="text"><![CDATA[不如来段紧张刺激的Hello,World代码如何： 1&gt;&gt;&gt; print("Hello,World!") THE END…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
