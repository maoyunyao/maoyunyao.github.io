<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zero contact]]></title>
    <url>%2F2019%2F05%2F13%2Fzero-contact%2F</url>
    <content type="text"><![CDATA[不如来段紧张刺激的Hello,World代码如何： 1&gt;&gt;&gt; print("Hello,World!") THE END…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Inline Assembler in GCC]]></title>
    <url>%2F2019%2F05%2F13%2Finline-asm-gcc%2F</url>
    <content type="text"><![CDATA[操作系统上机知识储备(一)对gcc所支持的内联汇编格式及使用方法进行简要的介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* * This c file is a introduction of inline Assembly for gcc * Time： 2018/9/8 * Author: myy * Reference： JeffreyLi https://www.jianshu.com/p/1782e14a0766*//////////////////////////////////////////////////////////////////////////////////////////////*Formular: asm ( assembler template : output operands // optional : input operands // optional : list of clobbered registers // optional ); The assembler template form: * form1:"sentence?sentence?sentence" * form2: "sentence?" "sentence?" "sentence" --- Where the ? should be replaced by "\n\t" or ";". --- Access to C variables by %0 %1 and so on. The operands form: * "constraint" (C expression) --- Where constraint is mainly used for note Addressing type(memory or register). --- For output operants, it should be decorated by "=", which means write-only. --- For multiple operants, they should be seperated by ",". --- To use the operants in assempler template with %0 %1 %2 ... - First output operants then input operants. - Signed in the list order. --- The output operants must be lvalue. The clobber list: * When a register is used in the assembler template, it should be in the clobber list. Which let gcc no longer assume that the values previously stored in these registers are still legal. * If the instruction changes the memory value in an unpredictable form, you need to add "memory" to the clobbered list.This allows GCC not to cache these memory values. The volatile: * If the assembly code is required to be executed at the location where it was placed (for example, it cannot be moved out of the loop during the optimization), we need to put a "volatile" keyword before the "()" after asm. This will prevent these codes from being moved or deleted. --- Useage: __asm__ __volatile__(...); Common constraints: *********************** * r Register(s) * a %eax, %ax, %al * b %ebx, %bx, %bl * c %ecx, %cx, %cl * d %edx, %dx, %adl * S %esi, %si * D %edi, %di *********************** * m memory *********************** --- If use the register constraint, the value will first be stored at the register used, and then write back to the memory in the end. --- Constraint "0" means: use the same register as the first output operants. Constraint Modifiers: * "=": Write only. * "&amp;": Means that this operand is an earlyclobber operand, which is modified before the instruction is finished using the input operands. Therefore, this operand may not lie in a register that is used as an input operand or as a part of any memory address.An input operand can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written.*/////////////////////////////////////////////////////////////////////////////////////////////#include&lt;stdio.h&gt;int main()&#123; int a = 10,b = 5,c; //Example: to realize c = a + b __asm__ __volatile__ ( "movl %2,%%eax\n\t movl %1,%%ebx\n\t addl %%ebx,%%eax\n\t movl %%eax,%0" :"=r"(c) :"r"(a),"r"(b) :"eax","ebx" ); printf("c = a + b = %d\n",c); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[机器学习之核函数]]></title>
    <url>%2F2019%2F05%2F13%2Fkernel_method%2F</url>
    <content type="text"><![CDATA[核函数对于线性不可分样本问题(如简单的异或问题), 可以将样本从原始空间映射到一个更高维的特征空间, 使得样本在这个特征空间内线性可分. 例如在支持向量机中, 原问题转化为求解特征空间上的凸二次规划问题: f(\textbf{x}) = w^T \phi(\textbf{x}) + b对上述线性可分支持向量机的求解涉及到如下对偶问题的求解(由拉格朗日乘子法得到对偶问题的具体过程此处不予讨论): \mathop{max}_\alpha \quad \sum\limits_{i = 1}^{n}\alpha_i-\frac{1}{2}\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}\alpha_i\alpha_jy_iy_j\phi(\textbf{x}_i)^T\phi(\textbf{x}_j)\\ s.t. \quad \sum\limits_{i=1}^{m}\alpha_iy_i=0\\ \alpha_i \ge 0, \quad i=1,2,...,m求解上式涉及到计算 $\phi(\textbf{x}_i)^T\phi(\textbf{x}_j)$, 这是样本 $\textbf{x}_i$ 与$\textbf{} $$\textbf{x}_j$ 映射到特征空间之后的内积. 由于特征空间维数很高, 甚至可能是无穷维, 因此直接计算通常是困难的. 为了避开这个障碍, 可以设想这样一个函数: k(\textbf{x}_i,\textbf{x}_j)==\phi(\textbf{x}_i)^T\phi(\textbf{x}_j)即 $\textbf{x}_i$ 与 $\textbf{x}_j$ 在特征空间的内积等于它们在原始样本空间中通过函数 $k(.,.)$ 计算的结果(此即核技巧). 有了这样的函数我们就不必直接去计算高维甚至无穷维特征空间中的内积, 于是对偶问题重写并求解可得 f(\textbf{x})=w^T\phi(\textbf{x})+b\\ =\sum\limits_{i=1}^{m}\alpha_iy_i\phi(\textbf{x}_i)^T\phi(\textbf{x})+b\\ =\sum\limits_{i=1}^{m}\alpha_iy_ik(\textbf{x},\textbf{x}_i)+b\\这里的函数 $k(.,.)$ 就是 “核函数” 显然, 如果已知合适的映射 $\phi(.)$ 的具体形式, 则可写出核函数 $k(.,.)$. 但是 现实任务重我们通常不知道 $\phi(.)$ 是什么形式. 剩下的问题就是如何选择 $\phi(.)$: 使用一个通用的 $\phi$, 例如无限维的 $\phi$, 它隐含地用在高斯核也即基于径向基函数 $(RBF)$ 核的核机器上 手动地设计 $\phi$ , 在深度学习出现以前, 这一直是主流的方法 深度学习的策略是去学习 $\phi$ 参考文献: [1]机器学习-周志华-第126, 127页 [2]深度学习-花书-第106页]]></content>
  </entry>
  <entry>
    <title><![CDATA[FFT with python]]></title>
    <url>%2F2019%2F05%2F13%2Ffft-by-python%2F</url>
    <content type="text"><![CDATA[来自信号与系统的一个小作业用python和其开源的科学计算库numpy实现快速傅里叶变换算法，并用数据可视化开源第三方库matplotlib作出频域图样。 代码实现如下12345678910111213141516171819202122232425262728293031323334#导入第三方库###############################from numpy import *from math import *import matplotlib.pyplot as plt################################ TO GET THE DATA（take gauss signal sampling for example）data_list = [ exp(-pi*x*x/1024/1024) for x in range(0,1024)]# FFT FUNCTION PART (递归蝶形算法，输入为数据点数目和数据点列)def my_fft_fun(NUM, DATA): if NUM == 1: return DATA else: ODD_DATA=DATA[0::2] EVEN_DATA=DATA[1::2] ODD_LIST=my_fft_fun(NUM//2, ODD_DATA) #奇偶分治 EVEN_LIST=my_fft_fun(NUM//2, EVEN_DATA) #奇偶分治 RES_DATA=[ EVEN_LIST[k%(NUM//2)]+ODD_LIST[k%(NUM//2)]*(cos(2*pi*k/NUM)+sin(2*pi*k/NUM)*1j) for k in range(0,NUM)] return RES_DATA#调用定义好的FFT递归求解函数FINAL_RES=my_fft_fun(1024,data_list)# 作出X(k)的模值与k的关系图x_part=range(0,1024)y_part=[ abs(val) for val in FINAL_RES]plt.scatter(x_part,y_part,s=5)plt.title('DFT for Gauss Signal', fontsize=20)plt.xlabel('k', fontsize=14)plt.ylabel('X(k)', fontsize=14)plt.show() 效果作图如下 有待改进之处算法仅涉及简单情形，即数据点的个数是2的指数倍，当需要计算非2的指数倍个数据点的FFT时，分治算法需要更加复杂。]]></content>
  </entry>
</search>
